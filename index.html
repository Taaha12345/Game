<!DOCTYPE html>
<html>
<head>
    <title>Neon Raider: Mission 1000</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Segoe UI', sans-serif; cursor: none; touch-action: none; }
        canvas { display: block; }
        .overlay {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; color: white; background: rgba(0, 0, 0, 0.95);
            padding: 20px; border-radius: 20px; border: 2px solid #00f2ff;
            width: 80%; max-width: 400px; z-index: 10; cursor: default;
        }
        h1 { font-size: 28px; margin: 0 0 10px 0; text-shadow: 0 0 15px #00f2ff; }
        .victory { border-color: #00ff88; box-shadow: 0 0 50px #00ff88; }
        .victory h1 { color: #00ff88; text-shadow: 0 0 15px #00ff88; }
        button { background: #00f2ff; color: #000; border: none; padding: 15px 30px; font-size: 18px; cursor: pointer; border-radius: 50px; font-weight: 900; width: 100%; margin-top: 10px; }
    </style>
</head>
<body>

    <div id="start-screen" class="overlay">
        <h1>NEON RAIDER</h1>
        <p>MISSION GOAL: 1000m<br>Avoid hazards, reach the stars.</p>
        <button onclick="startGame()">IGNITE</button>
    </div>

    <div id="game-over-screen" class="overlay" style="display: none;">
        <h1 id="end-title" style="color: #ff0055;">WRECKED</h1>
        <p id="end-msg"></p>
        <button onclick="startGame()">REDEPLOY</button>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const startScreen = document.getElementById("start-screen");
const gameOverScreen = document.getElementById("game-over-screen");
const endTitle = document.getElementById("end-title");
const endMsg = document.getElementById("end-msg");

let player, obstacles, powerups, stars, particles, projectiles, enemyProjectiles, score, isPlaying, baseGameSpeed, sector, lastAltTick, isVictory;
const SECTOR_COLORS = ["#00f2ff", "#ff00ff", "#00ff88", "#ffff00", "#ff4400"];

// Audio Setup
let audioCtx, ambientG;
function initAudio() {
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const osc1 = audioCtx.createOscillator();
    const osc2 = audioCtx.createOscillator();
    ambientG = audioCtx.createGain();
    osc1.type = 'sine'; osc1.frequency.setValueAtTime(40, audioCtx.currentTime);
    osc2.type = 'triangle'; osc2.frequency.setValueAtTime(42, audioCtx.currentTime);
    ambientG.gain.setValueAtTime(0.015, audioCtx.currentTime); 
    osc1.connect(ambientG); osc2.connect(ambientG);
    ambientG.connect(audioCtx.destination);
    osc1.start(); osc2.start();
}

function playSound(freq, type, duration, vol = 0.1) {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator(); const g = audioCtx.createGain();
    osc.type = type; osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    g.gain.setValueAtTime(vol, audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
    osc.connect(g); g.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + duration);
}

function doVibrate(pattern) { if ("vibrate" in navigator) navigator.vibrate(pattern); }

function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
window.addEventListener('resize', resize);
resize();

// Inputs
window.addEventListener("mousedown", () => { if(player && player.blasterTimer > 0) fireBlaster(); });
window.addEventListener("touchstart", (e) => { 
    if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
    if(player && player.blasterTimer > 0) fireBlaster(); 
});

const handleMove = (e) => {
    if(!isPlaying || !player || isVictory) return;
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    player.targetX = clientX - player.w / 2;
};
window.addEventListener("mousemove", handleMove);
window.addEventListener("touchmove", (e) => { e.preventDefault(); handleMove(e); }, {passive: false});

function fireBlaster() {
    projectiles.push({ x: player.x, y: player.y + 20, w: 8, h: 30, power: 2 });
    projectiles.push({ x: player.x + player.w/2 - 4, y: player.y - 20, w: 8, h: 30, power: 2 });
    projectiles.push({ x: player.x + player.w - 8, y: player.y + 20, w: 8, h: 30, power: 2 });
    playSound(700, 'square', 0.1, 0.03);
    doVibrate(15);
}

function startGame() {
    initAudio();
    if(audioCtx.state === 'suspended') audioCtx.resume();
    startScreen.style.display = "none";
    gameOverScreen.style.display = "none";
    gameOverScreen.classList.remove("victory");
    
    player = { x: canvas.width/2, targetX: canvas.width/2, y: canvas.height-150, w: 50, h: 100, color: "#00f2ff", shield: false, shrinkTimer: 0, blasterTimer: 0 };
    obstacles = []; powerups = []; particles = []; projectiles = []; enemyProjectiles = [];
    stars = []; for (let i = 0; i < 100; i++) stars.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, size: Math.random() * 2 + 1, speed: Math.random() * 3 + 1 });
    score = 0; isPlaying = true; isVictory = false; sector = 0; lastAltTick = Date.now();
    animate();
}

function winGame() {
    isVictory = true;
    playSound(400, 'sine', 0.5, 0.1);
    playSound(600, 'sine', 0.5, 0.1);
    doVibrate([50, 50, 50, 50, 100]);
    
    setTimeout(() => {
        isPlaying = false;
        gameOverScreen.classList.add("victory");
        endTitle.innerText = "MISSION COMPLETE";
        endMsg.innerText = "You reached 1000m and breached the stratosphere!";
        gameOverScreen.style.display = "block";
    }, 2000);
}

function update() {
    if (!isPlaying) return;

    if (!isVictory) {
        let now = Date.now();
        if (now - lastAltTick >= 250) { score += 2.5; lastAltTick = now; }
        
        // CHECK FOR MISSION COMPLETE
        if (score >= 1000) {
            score = 1000;
            winGame();
        }
    } else {
        // Victory flight: Move player up and speed up stars
        player.y -= 10;
        stars.forEach(s => s.speed *= 1.1);
    }

    sector = Math.floor(score / 50);
    let currentFallSpeed = isVictory ? 0 : (5 + (sector * 1.5));
    player.x += (player.targetX - player.x) * 0.2;
    player.color = SECTOR_COLORS[sector % SECTOR_COLORS.length];
    
    if (player.blasterTimer > 0) player.blasterTimer--;
    if (player.shrinkTimer > 0) player.shrinkTimer--;

    stars.forEach(s => { s.y += s.speed; if (s.y > canvas.height) s.y = 0; });
    particles.forEach((p, i) => { p.x += p.vx; p.y += p.vy; p.life -= 0.02; if (p.life <= 0) particles.splice(i, 1); });
    
    if (!isVictory) {
        projectiles.forEach((p, i) => {
            p.y -= 15;
            if (p.y < -50) projectiles.splice(i, 1);
            obstacles.forEach((obs, oi) => {
                if (rectIntersect(p, obs)) {
                    projectiles.splice(i, 1);
                    obs.hp -= p.power;
                    if (obs.hp <= 0) {
                        createExplosion(obs.x + obs.w/2, obs.y + obs.h/2, obs.type === 'boss' ? "#ff00ff" : "#ff0055", 15);
                        obstacles.splice(oi, 1);
                    }
                }
            });
        });

        enemyProjectiles.forEach((ep, i) => {
            ep.y += 8;
            if (ep.y > canvas.height) enemyProjectiles.splice(i, 1);
            if (rectIntersect(player, ep)) {
                if (player.shield) { player.shield = false; enemyProjectiles.splice(i, 1); doVibrate(30); } 
                else { endGame(); }
            }
        });

        obstacles.forEach((obs, i) => {
            obs.y += (obs.type === 'boss' ? 1.5 : currentFallSpeed);
            if (obs.type === 'boss') { 
                obs.x += Math.sin(Date.now()/400) * 6;
                if (Math.random() < 0.012) enemyProjectiles.push({ x: obs.x + obs.w/2 - 15, y: obs.y + obs.h, w: 30, h: 30 });
            }
            if (rectIntersect(player, obs)) {
                if (player.shield) { player.shield = false; obstacles.splice(i, 1); doVibrate(50); } 
                else { endGame(); }
            }
            if (obs.y > canvas.height) obstacles.splice(i, 1);
        });

        powerups.forEach((p, i) => {
            p.y += currentFallSpeed;
            if (rectIntersect(player, p)) {
                if (p.type === 'shield') player.shield = true;
                else if (p.type === 'shrink') player.shrinkTimer = 300;
                else if (p.type === 'blaster') player.blasterTimer = 600;
                doVibrate([20, 30, 20]);
                powerups.splice(i, 1);
            }
        });

        spawnEntities(sector);
    }
}

function spawnEntities(sector) {
    if (obstacles.some(o => o.y < 80)) return;
    if (score > 0 && Math.floor(score) % 150 === 0 && !obstacles.some(o => o.type === 'boss')) {
        obstacles.push({ x: canvas.width/2-75, y: -250, w: 150, h: 180, hp: 25 + sector*5, type: 'boss' });
    }
    if (Math.random() < 0.18 + (sector * 0.02)) {
        obstacles.push({ x: Math.random()*(canvas.width-40), y: -80, w: 40, h: 60, hp: 1, type: 'normal' });
    }
    if (Math.random() < 0.035) {
        let r = Math.random();
        powerups.push({ x: Math.random()*(canvas.width-30), y: -50, w: 30, h: 30, type: r > 0.85 ? 'blaster' : (r > 0.5 ? 'shrink' : 'shield') });
    }
}

function rectIntersect(a, b) { return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }
function createExplosion(x, y, color, count) { for (let i = 0; i < count; i++) particles.push({ x, y, vx: (Math.random()-0.5)*12, vy: (Math.random()-0.5)*12, size: Math.random()*3, life: 1, color }); }

function endGame() {
    isPlaying = false;
    doVibrate([100, 50, 100]);
    endTitle.innerText = "MISSION FAILED";
    endMsg.innerText = `You fell at ${score.toFixed(1)}m.`;
    gameOverScreen.style.display = "block";
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "white"; stars.forEach(s => ctx.fillRect(s.x, s.y, s.size, s.size));
    particles.forEach(p => { ctx.globalAlpha = p.life; ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, p.size, p.size); });
    ctx.globalAlpha = 1.0;

    projectiles.forEach(p => { ctx.fillStyle = "#ffcc00"; ctx.fillRect(p.x, p.y, p.w, p.h); });
    enemyProjectiles.forEach(ep => { 
        ctx.fillStyle = "#ff0055"; 
        ctx.beginPath(); ctx.arc(ep.x + ep.w/2, ep.y + ep.h/2, ep.w/2, 0, Math.PI*2); ctx.fill();
    });

    let pX = player.x, pY = player.y, pW = player.w, pH = player.h;
    if(player.shrinkTimer > 0) { pW /= 2; pH /= 2; pX += pW/2; pY += pH/2; }
    
    ctx.fillStyle = player.color; ctx.beginPath(); ctx.moveTo(pX+pW/2, pY); ctx.lineTo(pX+pW, pY+pH); ctx.lineTo(pX, pY+pH); ctx.fill();
    ctx.fillStyle = "#ff5500"; ctx.fillRect(pX+pW*0.3, pY+pH, pW*0.4, 12 + Math.random()*25);

    if (player.shield) { ctx.strokeStyle = "white"; ctx.lineWidth = 3; ctx.strokeRect(pX-8, pY-8, pW+16, pH+16); }

    obstacles.forEach(o => { ctx.fillStyle = o.type === 'boss' ? "#ff00ff" : "#ff0055"; ctx.fillRect(o.x, o.y, o.w, o.h); });
    powerups.forEach(p => {
        ctx.fillStyle = p.type === 'shield' ? "#00ff88" : (p.type === 'shrink' ? "#ffff00" : "#ffcc00");
        ctx.fillRect(p.x, p.y, p.w, p.h);
    });

    ctx.fillStyle = "white"; ctx.font = "bold 18px monospace";
    ctx.fillText(`ALTITUDE: ${score.toFixed(1)}m / 1000m`, 20, 30);
    if(player.blasterTimer > 0) ctx.fillText(`BLASTER: ${(player.blasterTimer/60).toFixed(1)}s`, 20, 55);
    
    if (isVictory) {
        ctx.fillStyle = "#00ff88"; ctx.font = "bold 40px sans-serif";
        ctx.textAlign = "center"; ctx.fillText("GOAL REACHED!", canvas.width/2, canvas.height/2);
        ctx.textAlign = "left";
    }
}

function animate() { if (isPlaying) { update(); draw(); requestAnimationFrame(animate); } }
</script>
</body>
</html>

